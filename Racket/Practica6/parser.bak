#lang plai

(require "grammars.rkt")

;; Función que realiza un mapeo entre símbols y funciones.
;; elige: symbol → procedure
(define (elige s)
   (match s
      ['+ +]
      ['- -]
      ['* *]
      ['/ /]
      ['modulo modulo]
      ['expt expt]
      ['add1 add1]
      ['sub1 sub1]
      ['not not]
      ['and (λ args (foldr (λ (x y) (and x y)) #t args))]
      ['or  (λ args (foldr (λ (x y) (or x y)) #f args))]
      ['< <]
      ['> >]
      ['<= <=]
      ['>= >=]
      ['= =]
      ['zero? zero?]
      ['empty? empty?]
      ['car car]
      ['cdr cdr]))

;; Análisis sintáctico
;; parse: s-expression → SAST
(define (parse sexp)
  (cond
    [(number? sexp) (numS sexp)]
    [(boolean? sexp) (boolS sexp)]
    [(eq? 'empty sexp) (listS '())]
    [(symbol? sexp) (cond
                      [(eq? 'true sexp) (boolS #t)]
                      [(eq? 'false sexp) (boolS #f)]
                      [else (idS sexp)])]
    [(condition? sexp)]
    [(list? sexp) (cond
             [(null? sexp) '()]
             [(number? (car sexp)) (parse-lista sexp)]
             [(eq? 'list (car sexp)) (listS (parse-lista (cdr sexp)))]
             ;;[(eq? 'rec (car sexp)) (recS (parse-lista-ex (cadr sexp) exception) (appS (parse (caaddr sexp)) (parse-lista (cdaddr sexp))))]
             [(eq? 'with* (car sexp)) (withS* (parse-bin (second sexp)) (parse (third sexp)) )]
             [(eq? 'with (car sexp)) (withS (parse-bin (second sexp)) (parse (third sexp)) )]
             [(eq? 'fun (car sexp)) (funS (second sexp) (parse (third sexp)) )]
             [(eq? 'if (car sexp)) (ifS (parse (second sexp)) (parse (third sexp)) (parse (third (cdr sexp))))]
             [(eq? 'cond (car sexp)) (condS (parse-cond (cdr sexp)))]
             [(funS? (parse (car sexp))) (appS (parse (car sexp)) (parse-lista (cdr sexp)))]
             [else (opS (elige (car sexp)) (append (list (parse(second sexp))) (parse-lista (cdr(cdr sexp)))))]
             )]))

;; Funcion auxiliar que hace parse a todos los elementos de una lista
;; parse-lista: (listof s-expression) → (listof SAST)
(define (parse-lista lista)
   (if (null? lista)
       '()
       (append (list (parse(car lista))) (parse-lista (cdr lista)))))

;; Funcion auxiliar que hace parse a todos los elementos de una lista de bindings
;; parse-bin: (listof s-expression) → (listof Binding)
(define (parse-bin bindings)
   (if (null? bindings)
       '()
       (append (list (binding (first (first bindings)) (parse (second (first bindings))))) (parse-bin (cdr bindings)))))


;; Funcion auxiliar que hace parse a todos los elementos de una lista, si encuentra
;; la exepción, no llama a la función parse, pero si lo cambia a una apps
;; parse-lista-ex: (listof s-expression) → (listof SAST)
(define (parse-lista-ex lista exception)
   (if (null? lista)
       '()
       (if (eq? exception (car lista))
           (append (list (appS (parse (car lista)) (parse-lista (cdr lista)))))
           (append (list (parse(car lista))) (parse-lista (cdr lista))))))

;; Funcion auxiliar que hace parse a todos los elementos de una lista de conditions
;; parse-cond: (listof s-expression) → (listof Condition)
(define (parse-cond lista)
   (if (null? (cdr lista))
       (list (else-cond (parse (second (car lista)))))
       (append (list (condition (parse (car (car lista))) (parse (second (car lista))))) (parse-cond (cdr lista)))))

#|
(define expr23 '{with {{p true} {q false}} {not {and p {or p q}}}})

(define expr29 '{rec {{fact {fun {n}
                         {if {zero? n}
                             1
                             {* n {fact {sub1 n}}}}}}}
                   {fact 5}})
(define expr30 '{rec {{len {fun {l}
                         {if {empty? l}
                             0
                             {+ 1 {len {cdr l}}}}}}}
                   {len {list 1 2 3}}})

(define expr34 '{rec {{longitud
                         {fun {l} 
                            {if {empty? l} 
                                0 
                                {+ 1 {longitud {cdr l}}}}}}
                      {suma
                         {fun {l}
                            {if {empty? l}
                                0
                                {+ {car l} {suma {cdr l}}}}}}
                      {lista {list 1 2 3}}}
       {+ {longitud lista} {suma lista}}})


(test (parse expr23)
      (withS (list (binding 'p (boolS #t)) (binding 'q (boolS #f))) 
             (opS not 
                 (list (opS (elige 'and) (list (idS 'p) 
                       (opS (elige 'or) (list (idS 'p) (idS 'q)))))))))
(test (parse expr29)
      (recS (list (binding 'fact 
                            (funS '(n) 
                                  (ifS (opS zero? (list (idS 'n))) 
                                       (numS 1) 
                                       (opS * 
                                           (list (idS 'n) 
                                           (appS (idS 'fact) 
                                                 (list (opS sub1 (list (idS 'n))))))))))) 
            (appS (idS 'fact) (list (numS 5)))))
(test (parse expr30)
      (recS (list (binding 'len 
                            (funS '(l) 
                                  (ifS (opS empty? (list (idS 'l))) 
                                       (numS 0) 
                                       (opS + 
                                            (list (numS 1) 
                                                  (appS (idS 'len) 
                                                        (list (opS cdr (list (idS 'l))))))))))) 
            (appS (idS 'len) (list (listS (list (numS 1) (numS 2) (numS 3)))))))

(test (parse expr34) 
      (recS (list (binding 'longitud 
                           (funS '(l) 
                                  (ifS (opS empty? (list (idS 'l))) 
                                       (numS 0) 
                                       (opS + 
                                           (list (numS 1)
                                                 (appS (idS 'longitud) 
                                                       (list (opS cdr (list (idS 'l))))))))))
                  (binding 'suma
                           (funS '(l)
                                  (ifS (opS empty? (list (idS 'l)))
                                       (numS 0)
                                      (opS +
                                          (list (opS car (list (idS 'l)))
                                                (appS (idS 'suma) 
                                                      (list (opS cdr (list (idS 'l))))))))))
                  (binding 'lista (listS (list (numS 1) (numS 2) (numS 3)))))
            (opS + 
                 (list (appS (idS 'longitud) (list (idS 'lista))) 
                       (appS (idS 'suma) (list (idS 'lista)))))))


|#